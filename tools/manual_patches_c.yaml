# This contains a bunch of small fixes specific to certain files that allow the challenges to be compiled in C++

# Format:
# [filename]:
#   - '[code to be replaced]': '[replacement]'
#   ...

# Patches that should be applied to all files
all:
  # Already defined in libcgc
  - ? |
      #ifndef NULL
      #define NULL ((void*)0)
      #endif
    : ''

  # Use nullptr instead of NULL
  - 'NULL': 'nullptr'

  # Reserved in C++
  - 'operator': '_operator'
  - 'template': '_template'
#  'this': '_this'

  # These types collide with some std lib types
  - 'timeval': 'cgc_timeval'
  - 'fd_set': 'cgc_fd_set'
#  'jmp_buf': 'cgc_jmp_buf'

  # Common mistake with calls to allocate
  - '(void *)&': '(void **)&'
  - '(void*)&': '(void **)&'

# Patches specific to the malloc.c lib
malloc.c:
  # Can't cast from void*
  - '= pNewChunk;': '= (tMallocAllocHdr *) pNewChunk;'
  - 'pNext = g_memManager.pFreeList': 'pNext = (tMallocAllocHdr *) g_memManager.pFreeList'
  - 'struct blk_t *blk = mem;': 'struct blk_t *blk = (struct blk_t *) mem;'

  # Pointer arithmetic not allowed on void*
  # Assuming they use void* in the sense that sizeof(void) == 1
  # Casting to char* instead acheives the same result
  - '#define FREE_BLOCK_NEXT( block )    (((tMallocAllocFtr *)((void *)block + (((tMallocAllocHdr *)block)->alloc_size & ~0x3)-sizeof(tMallocAllocHdr)))->pNext)': '#define FREE_BLOCK_NEXT( block )    (((tMallocAllocFtr *)((char *)block + (((tMallocAllocHdr *)block)->alloc_size & ~0x3)-sizeof(tMallocAllocHdr)))->pNext)'
  - '#define FREE_BLOCK_PREV( block )    (((tMallocAllocFtr *)((void *)block + (((tMallocAllocHdr *)block)->alloc_size & ~0x3)-sizeof(tMallocAllocHdr)))->pPrev)': '#define FREE_BLOCK_PREV( block )    (((tMallocAllocFtr *)((char *)block + (((tMallocAllocHdr *)block)->alloc_size & ~0x3)-sizeof(tMallocAllocHdr)))->pPrev)'
  - 'if ( ((void *)pNewChunkHeader + (pNewChunkHeader->alloc_size & ~0x3)-sizeof(tMallocAllocHdr)) != pFreeCurFooter )': 'if ( (tMallocAllocFtr *) ((char *)pNewChunkHeader + (pNewChunkHeader->alloc_size & ~0x3)-sizeof(tMallocAllocHdr)) != pFreeCurFooter )'
  - 'tMallocAllocHdr *pNeighbor = (pItem + (pItemHdr->alloc_size & ~0x3));': 'tMallocAllocHdr *pNeighbor = (tMallocAllocHdr *) ((char *)pItem + (pItemHdr->alloc_size & ~0x3));'
  - '(void *)pItemHdr': '(char *)pItemHdr'
  - 'pFreeCur +': '(char *) pFreeCur +'
  - 'pFreeCur+': '(char *) pFreeCur +'
  - '(pItem ': '((char *) pItem '
  - '(pAllocLocation ': '((char *) pAllocLocation '

# Patches specific to stdlib.c
stdlib.c:
  # Can't cast from void*
  - 'unsigned char *c = buff;': 'unsigned char *c = (unsigned char *) buff;'
  - 'heap_manager = mallocPtr;': 'heap_manager = (heap_metadata *) mallocPtr;'

  # Incorrect cast
  - '(void *)&': '(void **)&'

  # Use char* for pointer arithmetic instead of void*
  - '(void *)(chunkHeader)': '(char *)(chunkHeader)'
  - 'buf+total_sent': '(char *)buf+total_sent'

  # These functions should use char* instead of void* when incrementing through memory
  - 'void *memcpy(void *dest, void*src, unsigned int len) {': |
      void *memcpy(void *vdest, void*vsrc, unsigned int len) {
          char *dest = (char *) vdest;
          char *src = (char *) vsrc;

  - 'void *memset(void *dest, char c, unsigned int len) {': |
      void *memset(void *vdest, char c, unsigned int len) {
          char *dest = (char *) vdest;

  # More mem___ versions
  - ? |
      void *memcpy( void *dest, void *src, size_t numbytes )
      {
    : |
      void *memcpy( void *vdest, void *vsrc, size_t numbytes ) {
          char *dest = (char *) vdest;
          char *src = (char *) src;

  - ? |
      void *memset( void *dest, int value, size_t numbytes )
      {
    : |
      void *memset( void *vdest, int value, size_t numbytes ) {
          char *dest = (char *) vdest;

  - ? |
      void memcpy( void *dest, void *src, size_t numbytes )
      {
    : |
      void memcpy( void *vdest, void *vsrc, size_t numbytes ) {
          char *dest = (char *) vdest;
          char *src = (char *) src;


libc.c:
  - '(void *)buf +': '(char *)buf +'

printf.c:
  - "if ( str1 == '\\0' )": "if ( *str1 == '\\0' )"
  - '= arg;': '= (string_info_t *) arg;'

  - ? |
      int writeall(int fd, const void *buf, size_t n)
      {
    : |
      int writeall(int fd, const void *vbuf, size_t n) {
        const char *buf = (const char *) vbuf;

  - 'const void *bufend = buf + n;': 'const char *bufend = buf + n;'
  - 'const void *wptr = buf;': 'const char *wptr = buf;'

  # Args in wrong order
  - 'send_n_bytes(STDOUT, astring, strlen(astring));': 'send_n_bytes(STDOUT, strlen(astring), astring);'

strtol.c:
  - 'const char *idx = memchr(alphabet, tolower(c), base);': 'const char *idx = (const char *) memchr(alphabet, tolower(c), base);'

memset.c:
  - 'unsigned char *p = s;': 'unsigned char *p = (unsigned char *) s;'

memcmp.c:
  - ? |
      int memcmp(const char *s1, const char *s2, size_t n)
      {
    : int memcmp(void *vs1, const void *vs2, size_t n) {
          const char *s1 = (const char *) vs1;
          const char *s2 = (const char *) vs2;

realloc.c:
  # Reserved in c++
  - 'new': '_new'